// SPDX-FileCopyrightText: 2021 E F R <602406+Efruit@users.noreply.github.com>
// SPDX-FileCopyrightText: 2022 Paul Ritter <ritter.paul1@googlemail.com>
// SPDX-FileCopyrightText: 2022 mirrorcult <lunarautomaton6@gmail.com>
// SPDX-FileCopyrightText: 2022 wrexbe <81056464+wrexbe@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 /ʊniɹɑː/ <onoira@psiko.zone>
// SPDX-FileCopyrightText: 2023 Echo <SammyPawsM@gmail.com>
// SPDX-FileCopyrightText: 2023 Visne <39844191+Visne@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 eoineoineoin <eoin.mcloughlin+gh@gmail.com>
// SPDX-FileCopyrightText: 2024 Aiden <aiden@djkraz.com>
// SPDX-FileCopyrightText: 2024 Alzore <140123969+Blackern5000@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Brandon Hu <103440971+Brandon-Huu@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 CaasGit <87243814+CaasGit@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Chief-Engineer <119664036+Chief-Engineer@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Cojoke <83733158+Cojoke-dot@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 DrSmugleaf <10968691+DrSmugleaf@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 DrSmugleaf <DrSmugleaf@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Ed <96445749+TheShuEd@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Emisse <99158783+Emisse@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 EmoGarbage404 <retron404@gmail.com>
// SPDX-FileCopyrightText: 2024 Eoin Mcloughlin <helloworld@eoinrul.es>
// SPDX-FileCopyrightText: 2024 Errant <35878406+Errant-4@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Flareguy <78941145+Flareguy@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 FluffMe <dex.stb@gmail.com>
// SPDX-FileCopyrightText: 2024 Hrosts <35345601+Hrosts@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 IProduceWidgets <107586145+IProduceWidgets@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Ian <ignaz.k@live.de>
// SPDX-FileCopyrightText: 2024 Ilya246 <57039557+Ilya246@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Joel Zimmerman <JoelZimmerman@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 JustCone <141039037+JustCone14@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Killerqu00 <47712032+Killerqu00@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Ko4ergaPunk <62609550+Ko4ergaPunk@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Kukutis96513 <146854220+Kukutis96513@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Leon Friedrich <60421075+ElectroJr@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Lye <128915833+Lyroth001@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 MerrytheManokit <167581110+MerrytheManokit@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Mervill <mervills.email@gmail.com>
// SPDX-FileCopyrightText: 2024 Mr. 27 <45323883+Dutch-VanDerLinde@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 MureixloI <132683811+MureixloI@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 NakataRin <45946146+NakataRin@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Nemanja <98561806+EmoGarbage404@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 OrangeMoronage9622 <whyteterry0092@gmail.com>
// SPDX-FileCopyrightText: 2024 PJBot <pieterjan.briers+bot@gmail.com>
// SPDX-FileCopyrightText: 2024 Pieter-Jan Briers <pieterjan.briers+git@gmail.com>
// SPDX-FileCopyrightText: 2024 Plykiya <58439124+Plykiya@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Preston Smith <92108534+thetolbean@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Psychpsyo <60073468+Psychpsyo@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Repo <47093363+Titian3@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 RiceMar1244 <138547931+RiceMar1244@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 ShadowCommander <10494922+ShadowCommander@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Simon <63975668+Simyon264@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 SlamBamActionman <83650252+SlamBamActionman@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Southbridge <7013162+southbridge-fur@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Stalen <33173619+stalengd@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 TakoDragon <69509841+BackeTako@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Thomas <87614336+Aeshus@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 TsjipTsjip <19798667+TsjipTsjip@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Ubaser <134914314+UbaserB@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Unkn0wn_Gh0st <shadowstalkermll@gmail.com>
// SPDX-FileCopyrightText: 2024 Vasilis <vasilis@pikachu.systems>
// SPDX-FileCopyrightText: 2024 Vigers Ray <60344369+VigersRay@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 beck-thompson <107373427+beck-thompson@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 deathride58 <deathride58@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 deltanedas <39013340+deltanedas@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 deltanedas <@deltanedas:kde.org>
// SPDX-FileCopyrightText: 2024 dffdff2423 <dffdff2423@gmail.com>
// SPDX-FileCopyrightText: 2024 eoineoineoin <github@eoinrul.es>
// SPDX-FileCopyrightText: 2024 foboscheshir <156405958+foboscheshir@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 lzk <124214523+lzk228@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 metalgearsloth <31366439+metalgearsloth@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 metalgearsloth <comedian_vs_clown@hotmail.com>
// SPDX-FileCopyrightText: 2024 nikthechampiongr <32041239+nikthechampiongr@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 plykiya <plykiya@protonmail.com>
// SPDX-FileCopyrightText: 2024 saintmuntzer <47153094+saintmuntzer@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 shamp <140359015+shampunj@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 slarticodefast <161409025+slarticodefast@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 strO0pwafel <153459934+strO0pwafel@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 stroopwafel <j.o.luijkx@student.tudelft.nl>
// SPDX-FileCopyrightText: 2024 themias <89101928+themias@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 to4no_fix <156101927+chavonadelal@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 voidnull000 <18663194+voidnull000@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 Aiden <28298836+Aidenkrz@users.noreply.github.com>
//
// SPDX-License-Identifier: AGPL-3.0-or-later

using System.Numerics;
using Content.Client._RMC14.UserInterface.RichText;
using Content.Shared.Paper;
using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Robust.Client.Input;
using Robust.Client.ResourceManagement;
using Robust.Client.UserInterface.CustomControls;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Utility;
using Robust.Client.UserInterface.RichText;
using Content.Client.UserInterface.RichText;
using Robust.Shared.Input;

namespace Content.Client.Paper.UI
{
    [GenerateTypedNameReferences]
    public sealed partial class PaperWindow : BaseWindow
    {
        private PaperComponent.PaperBoundUserInterfaceState _currentState = default!; // RMC
        private string _currentRawText = string.Empty; // RMC
        [Dependency] private readonly IInputManager _inputManager = default!;
        [Dependency] private readonly IResourceCache _resCache = default!;

        private static Color DefaultTextColor = new(25, 25, 25);

        // Size of resize handles around the paper
        private const int DRAG_MARGIN_SIZE = 16;

        // We keep a reference to the paper content texture that we create
        // so that we can modify it later.
        private StyleBoxTexture _paperContentTex = new();

        // The number of lines that the content image represents.
        // See PaperVisualsComponent.ContentImageNumLines.
        private float _paperContentLineScale = 1.0f;

        // If paper limits the size in one or both axes, it'll affect whether
        // we're able to resize this UI or not. Default to everything enabled:
        private DragMode _allowedResizeModes = ~DragMode.None;

        private readonly Type[] _allowedTags = new Type[] {
            typeof(BoldItalicTag),
            typeof(BoldTag),
            typeof(BulletTag),
            typeof(ColorTag),
            typeof(HeadingTag),
            typeof(ItalicTag),
            typeof(MonoTag),
            typeof(FormTagHandler), // RMC
            typeof(SignatureTagHandler), // RMC
        };

        public event Action<string>? OnSaved;
        public event Action<int>? OnSignatureRequested; // RMC

        private int _MaxInputLength = -1;
        public int MaxInputLength
        {
            get => _MaxInputLength; // RMC
            set
            {
                _MaxInputLength = value;
                UpdateFillState();
            }
        }

        public PaperWindow()
        {
            IoCManager.InjectDependencies(this);
            RobustXamlLoader.Load(this);

            // We can't configure the RichTextLabel contents from xaml, so do it here:
            BlankPaperIndicator.SetMessage(Loc.GetString("paper-ui-blank-page-message"), null, DefaultTextColor);

            // Hook up the close button:
            CloseButton.OnPressed += _ => Close();

            Input.OnKeyBindDown += args => // Solution while TextEdit don't have events
            {
                if (args.Function == EngineKeyFunctions.MultilineTextSubmit)
                {
                    // SaveButton is disabled when we hit the max input limit. Just check
                    // that flag instead of trying to calculate the input length again
                    if (!SaveButton.Disabled)
                    {
                        RunOnSaved();
                        args.Handle();
                    }
                }
            };

            Input.OnTextChanged += args =>
            {
                UpdateFillState();
            };

            SaveButton.OnPressed += _ =>
            {
                RunOnSaved();
            };

            SaveButton.Text = Loc.GetString("paper-ui-save-button",
                ("keybind", _inputManager.GetKeyFunctionButtonString(EngineKeyFunctions.MultilineTextSubmit)));
        }

        /// <summary>
        ///     Initialize this UI according to <code>visuals</code> Initializes
        ///     textures, recalculates sizes, and applies some layout rules.
        /// </summary>
        public void InitVisuals(EntityUid entity, PaperVisualsComponent visuals)
        {
            // Randomize the placement of any stamps based on the entity UID
            // so that there's some variety in different papers.
            StampDisplay.PlacementSeed = (int)entity;

            // Initialize the background:
            PaperBackground.ModulateSelfOverride = visuals.BackgroundModulate;
            var backgroundImage = visuals.BackgroundImagePath != null? _resCache.GetResource<TextureResource>(visuals.BackgroundImagePath) : null;
            if (backgroundImage != null)
            {
                var backgroundImageMode = visuals.BackgroundImageTile ? StyleBoxTexture.StretchMode.Tile : StyleBoxTexture.StretchMode.Stretch;
                var backgroundPatchMargin = visuals.BackgroundPatchMargin;
                PaperBackground.PanelOverride = new StyleBoxTexture
                {
                    Texture = backgroundImage,
                    TextureScale = visuals.BackgroundScale,
                    Mode = backgroundImageMode,
                    PatchMarginLeft = backgroundPatchMargin.Left,
                    PatchMarginBottom = backgroundPatchMargin.Bottom,
                    PatchMarginRight = backgroundPatchMargin.Right,
                    PatchMarginTop = backgroundPatchMargin.Top
                };

            }
            else
            {
                PaperBackground.PanelOverride = null;
            }


            // Then the header:
            if (visuals.HeaderImagePath != null)
            {
                HeaderImage.TexturePath = visuals.HeaderImagePath;
                HeaderImage.MinSize = HeaderImage.TextureNormal?.Size ?? Vector2.Zero;
            }

            HeaderImage.ModulateSelfOverride = visuals.HeaderImageModulate;
            HeaderImage.Margin = new Thickness(visuals.HeaderMargin.Left, visuals.HeaderMargin.Top,
                    visuals.HeaderMargin.Right, visuals.HeaderMargin.Bottom);

            // Then the footer
            if (visuals.FooterImagePath is {} path)
            {
                FooterImage.TexturePath = path.ToString();
                FooterImage.MinSize = FooterImage.TextureNormal?.Size ?? Vector2.Zero;
            }

            FooterImage.ModulateSelfOverride = visuals.FooterImageModulate;
            FooterImage.Margin = new Thickness(visuals.FooterMargin.Left, visuals.FooterMargin.Top,
                    visuals.FooterMargin.Right, visuals.FooterMargin.Bottom);

            PaperContent.ModulateSelfOverride = visuals.ContentImageModulate;
            WrittenTextLabel.ModulateSelfOverride = visuals.FontAccentColor;
            FillStatus.ModulateSelfOverride = visuals.FontAccentColor;

            var contentImage = visuals.ContentImagePath != null ? _resCache.GetResource<TextureResource>(visuals.ContentImagePath) : null;
            if (contentImage != null)
            {
                // Setup the paper content texture, but keep a reference to it, as we can't set
                // some font-related properties here. We'll fix those up later, in Draw()
                _paperContentTex = new StyleBoxTexture
                {
                    Texture = contentImage,
                    Mode = StyleBoxTexture.StretchMode.Tile,
                };
                PaperContent.PanelOverride = _paperContentTex;
                _paperContentLineScale = visuals.ContentImageNumLines;
            }

            PaperContent.Margin = new Thickness(
                    visuals.ContentMargin.Left, visuals.ContentMargin.Top,
                    visuals.ContentMargin.Right, visuals.ContentMargin.Bottom);

            if (visuals.MaxWritableArea != null)
            {
                var a = (Vector2)visuals.MaxWritableArea;
                // Paper has requested that this has a maximum area that you can write on.
                // So, we'll make the window non-resizable and fix the size of the content.
                // Ideally, would like to be able to allow resizing only one direction.
                ScrollingContents.MinSize = Vector2.Zero;
                ScrollingContents.MinSize = a;

                if (a.X > 0.0f)
                {
                    ScrollingContents.MaxWidth = a.X;
                    _allowedResizeModes &= ~(DragMode.Left | DragMode.Right);

                    // Since this dimension has been specified by the user, we
                    // need to undo the SetSize which was configured in the xaml.
                    // Controls use NaNs to indicate unset for this value.
                    // This is leaky - there should be a method for this
                    SetWidth = float.NaN;
                }

                if (a.Y > 0.0f)
                {
                    ScrollingContents.MaxHeight = a.Y;
                    _allowedResizeModes &= ~(DragMode.Top | DragMode.Bottom);
                    SetHeight = float.NaN;
                }
            }
        }

        /// <summary>
        ///     Control interface. We'll mostly rely on the children to do the drawing
        ///     but in order to get lines on paper to match up with the rich text labels,
        ///     we need to do a small calculation to sync them up.
        /// </summary>
        protected override void Draw(DrawingHandleScreen handle)
        {
            // Now do the deferred setup of the written area. At the point
            // that InitVisuals runs, the label hasn't had it's style initialized
            // so we need to get some info out now:
            if (WrittenTextLabel.TryGetStyleProperty<Font>("font", out var font))
            {
                float fontLineHeight = font.GetLineHeight(1.0f);
                // This positions the texture so the font baseline is on the bottom:
                _paperContentTex.ExpandMarginTop = font.GetDescent(UIScale);
                // And this scales the texture so that it's a single text line:
                var scaleY = (_paperContentLineScale * fontLineHeight) / _paperContentTex.Texture?.Height ?? fontLineHeight;
                _paperContentTex.TextureScale = new Vector2(1, scaleY);

                // Now, we might need to add some padding to the text to ensure
                // that, even if a header is specified, the text will line up with
                // where the content image expects the font to be rendered (i.e.,
                // adjusting the height of the header image shouldn't cause the
                // text to be offset from a line)
                {
                    var headerHeight = HeaderImage.Size.Y + HeaderImage.Margin.Top + HeaderImage.Margin.Bottom;
                    var headerInLines = headerHeight / (fontLineHeight * _paperContentLineScale);
                    var paddingRequiredInLines = (float)Math.Ceiling(headerInLines) - headerInLines;
                    var verticalMargin = fontLineHeight * paddingRequiredInLines * _paperContentLineScale;
                    TextAlignmentPadding.Margin = new Thickness(0.0f, verticalMargin, 0.0f, 0.0f);
                }
            }

            base.Draw(handle);
        }

        /// <summary>
        ///     Initialize the paper contents, i.e. the text typed by the
        ///     user and any stamps that have peen put on the page.
        /// </summary>
        public void Populate(PaperComponent.PaperBoundUserInterfaceState state)
        {
            _currentState = state; // RMC
            _currentRawText = state.Text; // RMC
            var isEditing = state.Mode == PaperComponent.PaperAction.Write; // RMC

            // Show/hide UI elements based on edit mode
            InputContainer.Visible = isEditing;
            EditButtons.Visible = isEditing;
            WrittenTextLabel.Visible = !isEditing; // RMC
            WrittenTextContainer.Visible = false; // RMC
            BlankPaperIndicator.Visible = !isEditing && state.Text.Length == 0; // RMC

            if (isEditing) // RMC
            {
                // Initialize the text input field with server content if it's currently empty
                // This allows editing existing documents while preserving any text the user has already typed
                var shouldCopy = Input.TextLength == 0 && state.Text.Length > 0;
                if (shouldCopy)
                {
                    // We can get repeated messages with state.Mode == Write if another
                    // player opens the UI for reading. In this case, don't update the
                    // text input, as this player is currently writing new text and we
                    // don't want to lose any text they already input.
                    Input.TextRope = Rope.Leaf.Empty;
                    Input.CursorPosition = new TextEdit.CursorPos();
                    Input.InsertAtCursor(state.Text);
                }
                return;
            }
            //WrittenTextLabel.SetMessage(msg, _allowedTags, DefaultTextColor); - RMC

            //WrittenTextLabel.Visible = !isEditing && state.Text.Length > 0;
            //BlankPaperIndicator.Visible = !isEditing && state.Text.Length == 0;

            // Reset form and signature counters before processing to ensure consistent indexing
            // This is crucial because the tag handlers maintain state between renders
            FormTagHandler.SetFormText(state.Text); // RMC
            FormTagHandler.ResetFormCounter(); // RMC
            SignatureTagHandler.ResetSignatureCounter(); // RMC

            // Display text with markup processing (forms, signatures, colors, etc.)
            // The markup system converts [form] and [signature] tags into interactive buttons
            var fm = new FormattedMessage(); // RMC
            fm.AddMarkupPermissive(state.Text); // RMC
            WrittenTextLabel.SetMessage(fm, _allowedTags, DefaultTextColor); // RMC

            // Add stamps that have been applied to this paper
            // Clear existing stamps first, then add all current ones
            StampDisplay.RemoveAllChildren();
            StampDisplay.RemoveStamps();
            foreach (var stamper in state.StampedBy)
                StampDisplay.AddStamp(new StampWidget { StampInfo = stamper });
        }

        /// <summary>
        /// Base Window. Determines how the window can be dragged/resized based on mouse position (Like FancyWindow).
        /// Provides generous resize margins since paper UI may have rounded corners
        /// that make precise edge clicking difficult.
        /// </summary>
        /// <param name="relativeMousePos">Mouse position relative to window</param>
        /// <returns>Drag mode indicating which edges can be used for resizing</returns>
        protected override DragMode GetDragModeFor(Vector2 relativeMousePos)
        {
            var mode = DragMode.None;

            // Be quite generous with resize margins:
            if (relativeMousePos.Y < DRAG_MARGIN_SIZE)
                mode |= DragMode.Top;
            else if (relativeMousePos.Y > Size.Y - DRAG_MARGIN_SIZE)
                mode |= DragMode.Bottom;
            if (relativeMousePos.X < DRAG_MARGIN_SIZE)
                mode |= DragMode.Left;
            else if (relativeMousePos.X > Size.X - DRAG_MARGIN_SIZE)
                mode |= DragMode.Right;

            if ((mode & _allowedResizeModes) == DragMode.None)
                return DragMode.Move;

            return mode & _allowedResizeModes;
        }

        /// <summary>
        /// Handles the save operation by invoking the OnSaved event with current text.
        /// Temporarily disables the save button to prevent multiple simultaneous saves.
        /// </summary>
        private void RunOnSaved()
        {
            // Prevent further saving while text processing is in progress
            SaveButton.Disabled = true;
            OnSaved?.Invoke(Rope.Collapse(Input.TextRope));
            SaveButton.Disabled = false; // RMC
        }

        /// <summary>
        /// Updates the fill status display and save button state based on text length limits.
        /// Shows current character count vs maximum allowed, disables save if over limit.
        /// </summary>
        private void UpdateFillState()
        {
            if (MaxInputLength != -1)
            {
                var inputLength = Input.TextLength;
                // Display current vs maximum character count
                FillStatus.Text = Loc.GetString("paper-ui-fill-level",
                    ("currentLength", inputLength),
                    ("maxLength", MaxInputLength));
                // Disable the save button if we've exceeded the character limit
                SaveButton.Disabled = inputLength > MaxInputLength;
            }
            else
            {
                // No limit set, clear status and enable saving
                FillStatus.Text = "";
                SaveButton.Disabled = false;
            }
        }

        // RMC - START

        /// <summary>
        /// Removes any unfilled [form] and [signature] tags from the paper text.
        /// Called when the paper is stamped to finalize the document.
        /// </summary>
        /// <param name="text">The paper text to clean</param>
        /// <returns>Text with unfilled tags removed</returns>
        public static string CleanUnfilledTags(string text)
        {
            return text.Replace("[form]", string.Empty).Replace("[signature]", string.Empty);
        }

        /// <summary>
        /// Opens a modal dialog allowing the user to fill in a specific [form] tag.
        /// Creates a popup with text input, OK/Cancel buttons, and handles form submission.
        /// </summary>
        /// <param name="formIndex">Zero-based index of which [form] tag to replace</param>
        public void OpenFormDialog(int formIndex)
        {
            // Create the popup dialog structure
            var popup = new Popup();
            var vbox = new BoxContainer { Orientation = BoxContainer.LayoutOrientation.Vertical, Margin = new Thickness(10) };
            var editContainer = new PanelContainer { StyleClasses = { "TransparentBorderedWindowPanel" } };
            var edit = new LineEdit { MinSize = new Vector2(200, 0), Margin = new Thickness(5) };
            var hbox = new BoxContainer { Orientation = BoxContainer.LayoutOrientation.Horizontal };
            var ok = new Button { Text = Loc.GetString("paper-form-dialog-ok") };
            var cancel = new Button { Text = Loc.GetString("paper-form-dialog-cancel") };

            editContainer.AddChild(edit);

            // Handle OK button press - save the form data if text was entered
            ok.OnPressed += _ =>
            {
                if (!string.IsNullOrEmpty(edit.Text))
                {
                    var newText = ReplaceNthFormTag(_currentRawText, formIndex, edit.Text);
                    OnSaved?.Invoke(newText);
                }
                popup.Close();
            };

            // Handle Cancel button - just close without saving
            cancel.OnPressed += _ => popup.Close();

            // Handle Enter key in text field - same as OK button
            edit.OnTextEntered += _ =>
            {
                if (!string.IsNullOrEmpty(edit.Text))
                {
                    var newText = ReplaceNthFormTag(_currentRawText, formIndex, edit.Text);
                    OnSaved?.Invoke(newText);
                }
                popup.Close();
            };

            // Assemble the dialog layout and show it
            hbox.AddChild(ok);
            hbox.AddChild(cancel);
            vbox.AddChild(editContainer);
            vbox.AddChild(hbox);
            popup.AddChild(vbox);
            AddChild(popup);
            popup.Open();
            edit.GrabKeyboardFocus(); // Focus the text input for immediate typing
        }

        /// <summary>
        /// Sends a signature request to the server to handle signature with proper identity system.
        /// </summary>
        /// <param name="signatureIndex">Zero-based index of which [signature] tag to replace</param>
        public void SendSignatureRequest(int signatureIndex)
        {
            OnSignatureRequested?.Invoke(signatureIndex);
        }

        /// <summary>
        /// Replaces the nth occurrence of [form] tag with replacement text.
        /// Uses IndexOf for efficient searching rather than splitting the entire string.
        /// </summary>
        /// <param name="text">The text containing form tags</param>
        /// <param name="index">Zero-based index of which form tag to replace</param>
        /// <param name="replacement">Text to replace the form tag with</param>
        /// <returns>Text with the specified form tag replaced, or original text if index not found</returns>
        private static string ReplaceNthFormTag(string text, int index, string replacement)
        {
            const string formTag = "[form]";
            var currentIndex = 0;
            var pos = 0;

            // Search through the text for form tags
            while (pos < text.Length)
            {
                var foundPos = text.IndexOf(formTag, pos);
                if (foundPos == -1) break; // No more tags found

                // Check if this is the tag we want to replace
                if (currentIndex == index)
                {
                    // Replace this specific occurrence: text before + replacement + text after
                    return text.Substring(0, foundPos) + replacement + text.Substring(foundPos + formTag.Length);
                }

                // Move to the next tag
                currentIndex++;
                pos = foundPos + formTag.Length;
            }

            // Index not found, return original text unchanged
            return text;
        }

        /// <summary>
        /// Replaces the nth occurrence of [signature] tag with replacement text.
        /// Uses IndexOf for efficient searching rather than splitting the entire string.
        /// </summary>
        /// <param name="text">The text containing signature tags</param>
        /// <param name="index">Zero-based index of which signature tag to replace</param>
        /// <param name="replacement">Text to replace the signature tag with</param>
        /// <returns>Text with the specified signature tag replaced, or original text if index not found</returns>
        private static string ReplaceNthSignatureTag(string text, int index, string replacement)
        {
            const string signatureTag = "[signature]";
            var currentIndex = 0;
            var pos = 0;

            // Search through the text for signature tags
            while (pos < text.Length)
            {
                var foundPos = text.IndexOf(signatureTag, pos);
                if (foundPos == -1) break; // No more tags found

                // Check if this is the tag we want to replace
                if (currentIndex == index)
                {
                    // Replace this specific occurrence: text before + replacement + text after
                    return text.Substring(0, foundPos) + replacement + text.Substring(foundPos + signatureTag.Length);
                }

                // Move to the next tag
                currentIndex++;
                pos = foundPos + signatureTag.Length;
            }

            // Index not found, return original text unchanged
            return text;
        }
        // RMC - END
    }
}
