light_mode unshaded;

uniform highp float intensity;
uniform highp float speed;
uniform highp float textureHeight;

highp vec3 mod289(highp vec3 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

highp vec4 mod289(highp vec4 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

highp vec4 permute(highp vec4 x) {
     return mod289(((x*34.0)+10.0)*x);
}

highp vec4 taylorInvSqrt(highp vec4 r) {
  return 1.79284291400159 - 0.85373472095314 * r;
}

highp float snoise(highp vec3 v) {
  const highp vec2  C = vec2(1.0/6.0, 1.0/3.0);
  const highp vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

  highp vec3 i  = floor(v + dot(v, C.yyy));
  highp vec3 x0 = v - i + dot(i, C.xxx);
  highp vec3 g = step(x0.yzx, x0.xyz);
  highp vec3 l = 1.0 - g;
  highp vec3 i1 = min(g.xyz, l.zxy);
  highp vec3 i2 = max(g.xyz, l.zxy);
  highp vec3 x1 = x0 - i1 + C.xxx;
  highp vec3 x2 = x0 - i2 + C.yyy;
  highp vec3 x3 = x0 - D.yyy;

  i = mod289(i);
  highp vec4 p = permute(permute(permute(
             i.z + vec4(0.0, i1.z, i2.z, 1.0))
           + i.y + vec4(0.0, i1.y, i2.y, 1.0))
           + i.x + vec4(0.0, i1.x, i2.x, 1.0));

  highp float n_ = 0.142857142857;
  highp vec3  ns = n_ * D.wyz - D.xzx;

  highp vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
  highp vec4 x_ = floor(j * ns.z);
  highp vec4 y_ = floor(j - 7.0 * x_);
  highp vec4 x = x_ * ns.x + ns.yyyy;
  highp vec4 y = y_ * ns.x + ns.yyyy;
  highp vec4 h = 1.0 - abs(x) - abs(y);

  highp vec4 b0 = vec4(x.xy, y.xy);
  highp vec4 b1 = vec4(x.zw, y.zw);
  highp vec4 s0 = floor(b0) * 2.0 + 1.0;
  highp vec4 s1 = floor(b1) * 2.0 + 1.0;
  highp vec4 sh = -step(h, vec4(0.0));

  highp vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
  highp vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;
  highp vec3 p0 = vec3(a0.xy, h.x);
  highp vec3 p1 = vec3(a0.zw, h.y);
  highp vec3 p2 = vec3(a1.xy, h.z);
  highp vec3 p3 = vec3(a1.zw, h.w);

  highp vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
  p0 *= norm.x;
  p1 *= norm.y;
  p2 *= norm.z;
  p3 *= norm.w;

  highp vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
  m = m * m;
  return 105.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
}

highp vec3 rgb2hsv(highp vec3 c) {
    highp vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    highp vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    highp vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
    highp float d = q.x - min(q.w, q.y);
    highp float e = 0.0000000001;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

highp vec3 hsv2rgb(highp vec3 c) {
    highp vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    highp vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

highp float blendScreen(highp float base, highp float blend) {
    return 1.0 - ((1.0 - base) * (1.0 - blend));
}

highp vec3 blendScreen(highp vec3 base, highp vec3 blend) {
    return vec3(blendScreen(base.r, blend.r), blendScreen(base.g, blend.g), blendScreen(base.b, blend.b));
}

void fragment() {
    highp float dist_intensity = intensity;
    if (dist_intensity == 0.0) dist_intensity = 0.15;

    highp float dist_speed = speed;
    if (dist_speed == 0.0) dist_speed = 0.5;

    highp vec3 purple_color = vec3(0.5, 0.0, 1.0); // Bright purple

    highp vec2 distorted_uv = UV;

    highp float time1 = TIME * dist_speed * 0.3;
    highp float noise1 = snoise(vec3(UV * 3.0, time1));
    highp float noise2 = snoise(vec3(UV * 2.5 + 10.0, time1 * 1.2));

    distorted_uv.x += (noise1 - 0.5) * dist_intensity * 0.5;
    distorted_uv.y += (noise2 - 0.5) * dist_intensity * 0.3;

    highp float time2 = TIME * dist_speed * 1.2;
    highp float fine_noise = snoise(vec3(UV * 8.0, time2));
    distorted_uv += (fine_noise - 0.5) * dist_intensity * 0.1;

    highp float pulse = sin(TIME * dist_speed * 2.0) * 0.5 + 0.5;
    highp float pulse_noise = snoise(vec3(UV * 1.5, TIME * dist_speed * 0.5));
    distorted_uv += pulse_noise * dist_intensity * 0.05 * pulse;

    highp vec4 tex_color = texture(TEXTURE, distorted_uv);

    highp float distortion_amount = length(distorted_uv - UV);
    highp float purple_strength = clamp(distortion_amount * 4.0, 0.0, 0.7);

    highp vec3 tinted_color = mix(tex_color.rgb, purple_color, purple_strength * 0.5);

    highp vec3 purple_glow = purple_color * distortion_amount * 2.0;
    tinted_color = blendScreen(tinted_color, purple_glow);

    highp float scanline = sin(UV.y * textureHeight * 3.14159 * 2.0 + TIME * 5.0) * 0.1 + 0.9;
    tinted_color *= scanline;

    highp float glitch_noise = snoise(vec3(floor(UV * 64.0), TIME * 10.0));
    if (glitch_noise > 0.95) {
        tinted_color = vec3(0.8, 0.2, 1.0); // Bright purple flash
    }

    highp float edge = 1.0 - smoothstep(0.0, 0.2, min(min(UV.x, 1.0 - UV.x), min(UV.y, 1.0 - UV.y)));
    tinted_color *= 1.0 - edge * 0.3;

    highp float alpha_variation = 0.9 + 0.1 * sin(TIME * 2.0 + UV.x * 10.0);
    highp float final_alpha = tex_color.a * alpha_variation;

    COLOR = vec4(tinted_color, final_alpha);
}
